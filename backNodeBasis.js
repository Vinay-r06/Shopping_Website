// how does the web work?
// creating a Nodejs server?
//using Node Core Modules ?
// working with requests and responses(basics)?
// asynchronous code and the event loop?


// how does the web work?

// when u working in browser for submiting form..after submiting it will go the domain name server, domain lookup which is an encoded human readable version of that address..this url will lead to server then browser will send request to that server...
//browser in end is just  a interpreter.....displayed screen that is source code stored in server already or its generated by the server..
//offical of the each server is an IP address-->internet protocal address
// domain -- human readable---browser will contact 1st dns-- domain name system server--like huge dictionary..each domain name is mapped to an IP---this dns server translates u r (google.com)-> domain into IP address...this IP address given to the browser and with that browser can request to the server..which has the ip address...then server will generate the source code for website or stored source code ...this is sent back to the browser..where website will display
//metadata also called headers
// if on the server side we are genarating the page dynamically..on the server side... needs to be some code that runs and that is done with languages like nodejs or php...and also had frameworks for that -->express.js for node.js...frameworks are basically pacakages of utility functions that also give u some rules on how to use them that make writing code easy way---u can focus on bussiness and like parasing incoming requests is done by frameworks...u dont want see of an incoming request...u get the finished parase data...but do with that data instead of writing the parasing logic... 




//  What are the core modules of node js?

// http , https, fs, path, os.


//Explain the use of each one of them in detail.

//   http : Hypertext Transfer Protocol -->launching a server and sending requests because this also send request  to another server..

// https:  Hypertext Transfer Protocol Secure--> launch an SSL encoded server-- all data is transferred is encrypted end to end.

// fs:   module allows you to work with the file system on your computer. read files, create files, update files, delete files, rename files.

// path:  this path which helps us with constructing paths. paths to files on a files system that work on any operating system windows, mac, Linux.

// os: os package--> help us operating system, relevant system.




//What are relative path and absolute path? How to define them?

// 









                                            //-->start with -> ./http--relative path      ...absulote path--> /http
                                            //(./)-> this will lead to same folder and would now look for an http file.....
                                            //automatically adds .js (./http.js) 
                                            //(./http)--this will now look for local file named http..
                                            // if didnt put (./) or(/)..it will not look for local file..
                                            //(http)-->it will look for global module named http...if u had (http.js) it will not import this file...
                                            //

                                            // this file will execute in u r comuputer in cloud on the server....           
                                            // i will create server through nodejs
                                            // to spin the server
                                            // we again need to import functionality
                                            // there are couple of core modules nodejs ships with

                                            // core modules--> http , https, fs, path, os.. this path which helps us with constructing paths...paths to files on afiles system that work on any operating system win,mac linux
                                            //os package--> help us operating system, revelant system...
                                            // 2 top most packages ---> http and https---> these  2 imp when creating server and working with http requests and http responses.
                                            // http-->Hypertext Transfer Protocol -->lauching a server and sending requests because this also send request to another server..
                                            //https-->Hypertext Transfer Protocol Secure--> launch an ssl encoded server-- all data is transferred is encrypted.. 
                                            //
                                            // 
// const http =require('http');  
                                     // use http module-->need to import it....use require keyword can run via nodejs
 // function rqListener(req,res){


// }
                                                       // ways to import files in nodejs--->or dont have path...can also import core modules like(./http)...if (http)->looks global module--because nodejs ships it..
//http.createServer(rqListener);             // we do not excuete rqlistner()...we just telling the when create server...every request incoming this excute the function                                                   // now we can start using functionalities or methods and properties on objects, from that global module.....http object which we import from the http module...using createServer method                                                             
                                                            // request listner as argument-->this is --a function that will execute for every incoming request
                                                            //nodejs automatically gives us some object that reprents the incoming request and and object response..
                                                            // function argument  (1st is contain data about the request and the 2nd will send response  )





 // above code is explicity create function......we can create anaonymous function
 

//  const http =require('http');  
//  http.createServer(function(req,res){           // node will excuete this function whenever  request reaches our server...event driven architecture..nodejs uses heavly.....if a request comes, please execute this function.
 
// });



// create server callback function


// const http =require('http');  

// const server=http.createServer((req,res)=>{
//  console.log(req);                                      // open browser localhost:3000...u will not get anything because we are not return any html page...after opening browser see vs code terminal..there will be lot of output...because u  (req) console that

// });

// server.listen(3000)                                          // we got bunch of method...listen is one of them......listen starts the process where nodejs keep ruuning to listen ...
                                                   // default port 80....
                                                   // after excuete in terminal it will not come to new line because it is process here is still running....because ongoing looping process where keep on listening for requests...
                                                   // You want to have a web server that keeps on listening for requests.


 //output: type in browser -> localhost:3000
 // after running see in terminal all the methods and output will appear...






// assignment deliverable 1



// const http =require('http');  

//  const server=http.createServer((req,res)=>{
//  console.log('vinay');                                      // open browser localhost:3000...u will not get anything because we are not return any html page...after opening browser see vs code terminal..there will be lot of output...because u  (req) console that

//  });

 //server.listen(4000) 

 //output: vinay




 // assignment 2


 
// const http =require('http');  
//                                                 // for sending bold code below like this
// const server=http.createServer((req,res)=>{
// //  res.writeHead(200,{
// //      'Content-type': 'text/plain'            // 'Content-type': 'text/html'
// //  })                                

// res.write('vinay')                           //('<h1>vinay</h1>')
// res.end();
// });

// server.listen(4000) 

//output: vinay                                //output: vinay--> bold black color..




//  or do below like this alternative for above


// const http =require('http'); 
// const server=http.createServer((req, res) => {
// res.end('vinay from node');
// });

// server.listen(8000, '127.0.0.1', () => {                      // port number, then ip address standard number 127.0.0.1, callback function anything to print...
//     console.log('listening requests from port 8000');
// })



//output:  listening requests from port 8000-->vs terminal
           // vinay from node





// nodejs program lifecycle 

// process of create server:

// pgm.js--excuete
//started script---nodejs went throgh entire file, parsed the code, registered variables and function--read our entire code and start executed....
//event loop-- this aprocess which is managed by nodejs..which keeps on running as long as there is work to do---"keeps on running as long as there are event listeners registered"
// "the node application "--event loop --- all our code is managed by this...
//nodejs uses such an event driven approach for all stuff, not just managing that server..
//if u create server with nodejs..it should able to handle multiple like thousand are 10 thousand incoming requests..
//event loop-- it is super fast in handling requests...
//nodejs basically has an ongoing loop as long as there are listeners and create server creates listener which never stops..
//if u want unregister ...can do --- process.exit--it will end...quit from server...(.exit) nodejs saw that there is no more work to do...and give back to control to vs terminal


//code:



// const http =require('http'); 
// const server=http.createServer((req, res) => {
//  console.log(req);
//  process.exit();
// });
// server.listen(3000)


//output: after running in browser locallhost:3000--> in vs terminal the blink will come to the new line because process.exit()..



// controlling the nodejs process


//Want to quit your running Node.js server?

//You can always do that by pressing CTRL + C in the terminal/ command prompt window where you started your server (i.e. where you ran node app.js).




//understanding requests


// this request object is the object nodejs generated for us with all the data of the incoming request...
//metadata, meta information added to a request...



// const http =require('http'); 
// const server=http.createServer((req, res) => {
//  console.log(req.url, req.method, req.headers);                  // the url is basically everything after our host and we just have localhost,
 
// });
// server.listen(3000)


//output: in terminal u will get
// url->/ 
//get--method                                         //get is default method used if you just enter a url into your browser.
//headers                                            // run this type  http://localhost:3000/test ...after in terminal and network tab  shows like this---> /tset GET{}




//  sending responses



// const http =require('http'); 
// const server=http.createServer((req, res) => {
//     console.log(req.url, req.method, req.headers); 
//     res.setHeader('Content-Type', 'text/html');                    //set new header ....'content-type' is default header which browser can understand..
//   res.write('<html>');
//   res.write('<head><title>my first page</title></header>')
//   res.write('<boby><h1>hello from my nodejs server </h1></boby>')
//   res.write('</html>');
//   res.end();
// });

// server.listen(3000)                             

                                                        // in network tab there is of default headers which are set by the server
//output:  hello from my nodejs server                // http://localhost:3000/test                                        




//assignment


// const http =require('http'); 
// const server=http.createServer((req, res) => {
//   console.log(req.url, req.method, req.headers);
//   let url=req.url;
//   res.setHeader('Content-Type', 'text/html');

//   if(url=='/home'){
//   res.write('<html>'); 
//   res.write('<head><title>my first page</title></header>')
//   res.write('<boby><h1>Welcome home </h1></boby>')
//   res.write('</html>');
// }

//   else if(url=='/about'){
//     res.setHeader('Content-Type', 'text/html'); 
//     res.write('<html>'); 
//     res.write('<head><title>my first page</title></header>')
//     res.write('<boby><h1>Welcome to About Us page </h1></boby>')
//     res.write('</html>');
//   }
//   else if(url=='/node'){
//     res.setHeader('Content-Type', 'text/html'); 
//     res.write('<html>'); 
//     res.write('<head><title>my first page</title></header>')
//     res.write('<boby><h1>Welcome to my Node Js project </h1></boby>')
//     res.write('</html>');

//   }
//   res.end();
//  });

//  server.listen(4000, 'localhost', () => {                      // port number, then ip address standard number 127.0.0.1, callback function anything to print...
//      console.log('listening requests from port 8000');
//  })






 

//  Routing and Requests


                                //A GET request is automatically sent when you click a link or enter a url, a POST request has to be set up by you by creating such a form,


// const http =require('http'); 
// const server=http.createServer((req, res) => {
// const url =req.url;
// if(url=='/'){
    
//       res.write('<html>'); 
//       res.write('<head><title>Enter Message</title></header>')
//       res.write('<boby><form action="/message" method="POST"><input type="text" name="message"></input> <button type="submit">Send</button></form></boby>')                      // name="message"...if we give that input a name which we should, message, it will also automatically put that message  into the request it sends to our server....the name does not have to be "message"..it will add any input data to the request and make it accessible via the assigned name...

     
//       res.write('</html>');
//       return res.end();
// }

// res.setHeader('Content-Type', 'text/html'); 
//     res.write('<html>'); 
//     res.write('<head><title>my first page</title></header>')
//     res.write('<boby><h1>Welcome to my Node Js project </h1></boby>')
//     res.write('</html>');
//     res.end();
//   });

//   server.listen(3000) ;   


// output: when u gave input to that form it will excute "welcome to my nodejs project"...because now the url is /message and /message does not make it into this if statement and therefore this code runs...







//redirecting requests



// const http =require('http');
// const  fs  = require('fs'); 
// const server=http.createServer((req, res) => {
// const url =req.url;
// const method = req.method;
// if(url==='/'){
    
//       res.write('<html>'); 
//       res.write('<head><title>Enter Message</title></header>')
//       res.write('<boby><form action="/message" method="POST"><input type="text" name="message"></input> <button type="submit">Send</button></form></boby>')                      // name="message"...if we give that input a name which we should, message, it will also automatically put that message  into the request it sends to our server....the name does not have to be "message"..it will add any input data to the request and make it accessible via the assigned name...
//       res.write('</html>');
//       return res.end();
// }

// if(url==='/message' && method ==='POST'){
//       fs.writeFileSync('message.txt','DUMMY');
//       res.statusCode=302;
//       res.setHeader('Location', '/');                          //we set the location, this is also a default header accepted by the browser..../-->use the host we're already running on
//       return res.end();

// }
//     res.setHeader('Content-Type', 'text/html'); 
//     res.write('<html>'); 
//     res.write('<head><title>my first page</title></header>')
//     res.write('<boby><h1>Welcome to my Node Js project </h1></boby>')
//     res.write('</html>');
//     res.end();
//   });

//   server.listen(3000) ; 


//output: after excuete --message.txt will file will create and in that "dummy" willl there...  





// parsing Request Bodies..




                                                          
                               //incoming data is basically sent as a stream of data and that is a special construct javascript
                                                          
                                       //the request is simply read by node in chunks
                                                           
                                                          // suppose file being uploaded will take more time means longer ..in that time..streaming that data could make sense...because it could allow u to start writing this to u r disk, so u r hard drive where u r node app runs on ur server.....vast  data is coming in, so that you don't have to parse the entire file which taking some time and u want to wait for fully uploaded....before u can do anything with it.....this is how node handles all requests because it doesnt know in advance how complex and big they are.... 
                                                     // can start working on the data earlier,the problem is with your code, you can't arbitrarily try to work with these chunks. Instead to organize these incoming chunks,---> use buffer
                                                     ////A buffer is simply a construct which allows you to hold multiple chunks and work with them before they are released once you're done and you work with that buffer.
                                                     // (.on)method--->allows to listen to certain events.
                                                     //the data event will be fired whenever a new chunk is ready to be read,
                                                     // second argument --> incoming data peiece
                                                     //const--> with push we're changing the object behind that body element, that body object, we're editing that data in that object not the value itself, not the object itself.
                                                    //(end)-->once it's done parsing the incoming requests data or the incoming requests..
                                                    // (toString) method--> is utility methos by nodejs.....y we convert string-->because we know--> the body of that request will be text.. if it is file we can different...

                                                        

//  const http =require('http');
//  const  fs  = require('fs'); 
//  const server=http.createServer((req, res) => {
//  const url =req.url;
//  const method = req.method;
//  if(url==='/'){
                                                        
// res.write('<html>'); 
// res.write('<head><title>Enter Message</title></header>')
// res.write('<boby><form action="/message" method="POST"><input type="text" name="message"></input> <button type="submit">Send</button></form></boby>')                      // name="message"...if we give that input a name which we should, message, it will also automatically put that message  into the request it sends to our server....the name does not have to be "message"..it will add any input data to the request and make it accessible via the assigned name...
// res.write('</html>');
// return res.end();
//     }
                                                    
// if(url==='/message' && method ==='POST'){
//  const body = [];
//  req.on('data', (chunk)=>{
//       console.log(chunk);
//       body.push(chunk);
//  });
//  req.on('end', ()=>{
//       const parseBody= Buffer.concat(body).toString();
//       console.log(parseBody);
//  });     
// fs.writeFileSync('message.txt','DUMMY');
// res.statusCode=302;
// res.setHeader('Location', '/');                          //we set the location, this is also a default header accepted by the browser..../-->use the host we're already running on
// return res.end();
                                                    
//       }

// res.setHeader('Content-Type', 'text/html'); 
// res.write('<html>'); 
// res.write('<head><title>my first page</title></header>')
// res.write('<boby><h1>Welcome to my Node Js project </h1></boby>')
// res.write('</html>');
// res.end();

// });
                                                    
//             server.listen(3000) ; 



//output:  <Buffer 6d 65 73 73 61 67 65 3d 62 67 62 67 62 67>        --> console.log(chunk);
//          message=bgbgbg           ....key value pair...key is message( we named as "message") and value is user entered            -->  console.log(parseBody);   







// const http =require('http');
//  const  fs  = require('fs'); 

//  const server=http.createServer((req, res) => {
//  const url =req.url;
//  const method = req.method;
//  if(url==='/'){
                                                        
// res.write('<html>'); 
// res.write('<head><title>Enter Message</title></header>')
// res.write('<boby><form action="/message" method="POST"><input type="text" name="message"></input> <button type="submit">Send</button></form></boby>')                      // name="message"...if we give that input a name which we should, message, it will also automatically put that message  into the request it sends to our server....the name does not have to be "message"..it will add any input data to the request and make it accessible via the assigned name...
// res.write('</html>');
// return res.end();
//     }
                                                    
// if(url==='/message' && method ==='POST'){
//  const body = [];
//  req.on('data', (chunk)=>{
//       console.log(chunk);
//       body.push(chunk);
//  });
//  req.on('end', ()=>{
//       const parseBody= Buffer.concat(body).toString();
//       const message=parseBody.split('=')[1];                              //  u will right side of the equal sign  means --> message= hello----- u will get-> hello
//       //console.log(message)
//      // console.log(parseBody);
//       fs.writeFileSync('message.txt', message);
//  });     

// res.statusCode=302;
// res.setHeader('Location', '/');                          //we set the location, this is also a default header accepted by the browser..../-->use the host we're already running on
// return res.end();
                                                    
//       }

// res.setHeader('Content-Type', 'text/html'); 
// res.write('<html>'); 
// res.write('<head><title>my first page</title></header>')
// res.write('<boby><h1>Welcome to my Node Js project </h1></boby>')
// res.write('</html>');
// res.end();

// });
                                                    

// server.listen(3000) ; 


//output: u will output when run localhost runs...in the vs code in message.txt file u will see wat u typed in submit box...message.txt file will create in vs code....





// understanding event driven code excuetion...


// const http =require('http');
//  const  fs  = require('fs'); 

//  const server=http.createServer((req, res) => {
//  const url =req.url;
//  const method = req.method;
//  if(url==='/'){
                                                        
// res.write('<html>'); 
// res.write('<head><title>Enter Message</title></header>')
// res.write('<boby><form action="/message" method="POST"><input type="text" name="message"></input> <button type="submit">Send</button></form></boby>')                      // name="message"...if we give that input a name which we should, message, it will also automatically put that message  into the request it sends to our server....the name does not have to be "message"..it will add any input data to the request and make it accessible via the assigned name...
// res.write('</html>');
// return res.end();
//     }
                                                    
// if(url==='/message' && method ==='POST'){
//  const body = [];
//  req.on('data', (chunk)=>{
//       console.log(chunk);
//       body.push(chunk);
//  });
//  req.on('end', ()=>{
//       const parseBody= Buffer.concat(body).toString();
//       const message=parseBody.split('=')[1];                              //  u will right side of the equal sign  means --> message= hello----- u will get-> hello
//       //console.log(message)
//      // console.log(parseBody);
//       fs.writeFileSync('message.txt', message);
//  });     

// res.statusCode=302;
// res.setHeader('Location', '/');                          //we set the location, this is also a default header accepted by the browser..../-->use the host we're already running on
// return res.end();
                                                    
//       }

// res.setHeader('Content-Type', 'text/html'); 
// res.write('<html>'); 
// res.write('<head><title>my first page</title></header>')
// res.write('<boby><h1>Welcome to my Node Js project </h1></boby>')
// res.write('</html>');
// res.end();

// });
                                                    

// server.listen(3000) ; 




//explanation for above 

// fs.writeFileSync('message.txt', message);  --> this will line  excuete after  -->res.statusCode=302;
                                                                             //    res.setHeader('Location', '/'); 
                                                                           //      return res.end();
                                             // it will even excute after  we already sent a response                                    
                                               // if we do something in the event listner it should be influence response...
// so crt way to code is below

// return req.on('end', ()=>{
//      const parseBody= Buffer.concat(body).toString();
//      const message=parseBody.split('=')[1];   
//      fs.writeFileSync('message.txt', message);
//      res.statusCode=302;                                               //we should move response code into event listner...if had such dependancy
//      res.setHeader('Location', '/');                         
//      return res.end(); 
// });
// }
// res.setHeader('Content-Type', 'text/html');         

// if pass function to function ...--> createserver(req,res)
// asynchronous excuetion ----> when encounter --> res----> this will add a new event listener internally...
                                                          // it manages all listners internaaly
                                                         // end event on the request--> which will triggers once nodejs is done parsing the request..
                                                         // and after function will call once its done...
                                                         //nodejs having some internal registrty of events and listners to these events...
                                                         //  function like this ----()=>{
                                                         //                         const parseBody= Buffer.concat(body).toString();
                                                         //                           const message=parseBody.split('=')[1];   
                                                         //                             fs.writeFileSync('message.txt', message);  

                                                         //                                     });
                                                         //                                            }
                                                         //      function like this   called----> listener
                                                         // when nodejs is done prasing request it will go through that registry and see im done with request...should now send the end event...
                                              
                                                         // see which listeners i have for that  and excuete function that is registered for that and call them..
                                                         // 1st----> go to --> if satement and if true inside if
                                                         // 2nd ---->       and then register 2 handlers and immediately excuete these 2 functions...fun just register internally in its event registry and then straight next line....res.setHeader()
                                                         //after excute = it will excute --res.setHeader
                                                         /// error --> header cant set-- because already moved along and excuted...after this tried to again send response-->res.status=302... which is too late because already excuted--> res.setHeader()-- to ---res.end()
                                                         // y this happens because res.on(end)--->()=>{

                                                         //   }
                                                         // this is call back called sometime in future....the setup is impoertant otherwise node should be wait untill it done....not able handle other incoming requests..untill its done..we dont want block code excuetion..
                                                         
                                                         //We always want to be in that wait for new events, loop the event loop and then only execute code once its due to be excuted..never block that event loop for too long time...
                                                         
                                                         // so to avoid this return req.on()..and after res.setHeader will not excute..if u put return ...

// filewriteSync and remaining code putting inside res.on 


// const http =require('http');
// const  fs  = require('fs'); 
// const server=http.createServer((req, res) => {
// const url =req.url;
// const method = req.method;

// if(url==='/'){         
// res.write('<html>'); 
//  res.write('<head><title>Enter Message</title></header>')
// res.write('<boby><form action="/message" method="POST"><input type="text" name="message"></input> <button type="submit">Send</button></form></boby>')                      // name="message"...if we give that input a name which we should, message, it will also automatically put that message  into the request it sends to our server....the name does not have to be "message"..it will add any input data to the request and make it accessible via the assigned name...
// res.write('</html>');
// return res.end();
//  }
                                                                                                             
// if(url==='/message' && method ==='POST'){
// const body = [];

// req.on('data', (chunk)=>{
// console.log(chunk);
// body.push(chunk);
//  });

// req.on('end', ()=>{
// const parseBody= Buffer.concat(body).toString();
// const message=parseBody.split('=')[1];                              //  u will right side of the equal sign  means --> message= hello----- u will get-> hello
//           //console.log(message)
//           // console.log(parseBody);
// fs.writeFileSync('message.txt', message);
// res.statusCode=302;
// res.setHeader('Location', '/');
// return res.end();
// });     
                                                                                                                                                                
//  }                                                     
// res.setHeader('Content-Type', 'text/html'); 
// res.write('<html>'); 
// res.write('<head><title>my first page</title></header>')
// res.write('<boby><h1>Welcome to my Node Js project </h1></boby>')
// res.write('</html>');
// res.end();
                                                         
//  });
                                                                                                             
                                                         
// server.listen(3000) ; 
                                                         

//output:   Welcome to my Node Js project        ---in browser..
//  Error [ERR_HTTP_HEADERS_SENT]: Cannot set headers after they are sent to the client ....-->           because explanation is above...it directly excueting nect line...so use return in res.on
//  code: 'ERR_HTTP_HEADERS_SENT'




// blocking and non blocking.....



// assign "return"  to res.end and 3rd argument as function error object...and using "filewrite"


// const http =require('http');
// const  fs  = require('fs'); 
//  const server=http.createServer((req, res) => {
// const url =req.url;
//  const method = req.method;

// if(url==='/'){         
// res.write('<html>'); 
//  res.write('<head><title>Enter Message</title></header>')
// res.write('<boby><form action="/message" method="POST"><input type="text" name="message"></input> <button type="submit">Send</button></form></boby>')                      // name="message"...if we give that input a name which we should, message, it will also automatically put that message  into the request it sends to our server....the name does not have to be "message"..it will add any input data to the request and make it accessible via the assigned name...
// res.write('</html>');
// return res.end();
//  }
                                                                                                             
// if(url==='/message' && method ==='POST'){
// const body = [];

// req.on('data', (chunk)=>{
// console.log(chunk);
// body.push(chunk);
//  });

// return req.on('end', ()=>{
// const parseBody= Buffer.concat(body).toString();
// const message=parseBody.split('=')[1];                              //  u will right side of the equal sign  means --> message= hello----- u will get-> hello
//           //console.log(message)
//           // console.log(parseBody);
// fs.writeFile('message.txt', message, (err)=>{                          // using filewrite which gives 3 rd arguments as function ..call back function which recevies error....if error it will return error response ..if no error return normal response...
//      res.statusCode=302;                                              // normal response only sent  only done working with the file ....function excute only when the message write is done.....here not handling error because here no error will come...normal response using...
//      res.setHeader('Location', '/');                              
//      return res.end();                                             // event listener with method and functions---> event listener--req.on('end')...method or function---()=>{ const parseBody=buff   to  return res.end();}  method or function will be excuted once done prasing the request...that function  will excutes in sometime future..
//                                                                    // we had another event listener, this nested function..which excuted once done writing the file
//                                                                    // // we had event drive architecture(eda):--> err=>{  inside function}---eda u will tell nodejs pls do something-- it go and offload that process to the operating system which is use multi-threading...and then continue its event loop to listen for event callbacks...and then always come back once an operation is done by operating system... does something in the callback({}inside callback function, wat code is excuted), like send response here code..

// });                                                                 

// });     
                                                                                                                                                                
//  }                                                     
// res.setHeader('Content-Type', 'text/html'); 
// res.write('<html>'); 
// res.write('<head><title>my first page</title></header>')
// res.write('<boby><h1>Welcome to my Node Js project </h1></boby>')
// res.write('</html>');
// res.end();
                                                         
//  });
                                                                                                             
                                                         
// server.listen(3000) ; 
                       



// output: hello+vinay --> created in file vs code
       // nothing just input box after given input----->  in browser 



// explanation for above topic..

// fs.writeFileSync('message.txt', message);---> writefilesync means sync--  synchronous...special method which will actually block code execution until this file is created.
// working with files in 2 modes..
// synchronos mode : we block excuetion of the next line of code untill this file is done..
// but large files megabytes cant wait this much takes slow server if u do read or write..if block excuetion other code will not contuine untill that file operation is done...
//new incoming requests of others user would no tbe handled until file opertaion is done...
//better use:= ---> writeFile--->gives accept the path, data, and callback as 3rd argument...
// callback is function should excute when its done..

// nodejs implicitly registers an event listener for us
// 3rd argument -- function as error object which will be null is no error...
// if error occured u will get it and handled here...
// below code for error handle and 3rd argument as function...for fileWrite...






//  assignment read from file and show it on browser display....


// const http =require('http');
// const  fs  = require('fs'); 
//  const server=http.createServer((req, res) => {
// const url =req.url;
//  const method = req.method;

// if(url==='/'){

// fs.readFile('message.txt',{encoding:'utf-8'}, (err,data)=>{
//      if(err){
//           console.log(err);
//      }
//   console.log(data);
// res.write('<html>'); 
// res.write('<head><title>Enter Message</title></header>')
// res.write(`<body>${data}</body>`)
// res.write('<boby><form action="/message" method="POST"><input type="text" name="message"></input> <button type="submit">Send</button></form></boby>')                      // name="message"...if we give that input a name which we should, message, it will also automatically put that message  into the request it sends to our server....the name does not have to be "message"..it will add any input data to the request and make it accessible via the assigned name...
// res.write('</html>');
// return res.end();
// })
//  }
                                                                                                             
// else if(url==='/message' && method ==='POST'){
// const body = [];

// req.on('data', (chunk)=>{
// console.log(chunk);
// body.push(chunk);
//  });

// return req.on('end', ()=>{
// const parseBody= Buffer.concat(body).toString();
// const message=parseBody.split('=')[1];                              //  u will right side of the equal sign  means --> message= hello----- u will get-> hello
//           //console.log(message)
//           // console.log(parseBody);
// fs.writeFile('message.txt', message, (err)=>{                          // using filewrite which gives 3 rd arguments as function ..call back function which recevies error....if error it will return error response ..if no error return normal response...
//      res.statusCode=302;                                              // normal response only sent  only done working with the file ....function excute only when the message write is done.....here not handling error because here no error will come...normal response using...
//      res.setHeader('Location', '/');                              
//      return res.end();                                             // event listener with method and functions---> event listener--req.on('end')...method or function---()=>{ const parseBody=buff   to  return res.end();}  method or function will be excuted once done prasing the request...that function  will excutes in sometime future..
//                                                                    // we had another event listener, this nested function..which excuted once done writing the file
//                                                                     // // we had event drive architecture(eda):--> err=>{  inside function}---eda u will tell nodejs pls do something-- it go and offload that process to the operating system which is use multi-threading...and then continue its event loop to listen for event callbacks...and then always come back once an operation is done by operating system... does something in the callback({}inside callback function, wat code is excuted), like send response here code..

// });                                                      

// });     


//  }       
// else{
// res.setHeader('Content-Type', 'text/html'); 
// res.write('<html>'); 
// res.write('<head><title>my first page</title></header>')
// res.write('<boby><h1>Welcome to my Node Js project </h1></boby>')
// res.write('</html>');
// res.end();
// }                                              
//  });
                                                                                                             
                                                         
// server.listen(3000) ;


//  output: hello+rahul---in browser above box will shown wat is in the file will print in the display..                      
//      in vs terminal : hello+rahul--- shows wat is in the file will print...
// 


// file read and write is asynchronous..

   




// nodejs --looking behind the scenes..


// event loop given by nodejs..it implictly start by nodejs when code excuted started...
//event loop is responsible for handling event callbacks..
//file operation does not handle by event loop...
//in call back we defining write file once its done...that code will be handled by event loop..
//event loop will only handle callbacks that contain fast finishing code...
//file operation and other long taking operation are sent to worker pool...
//worker pool: responsible for all the heavy lifting... this pool is detected to u r javascript code which runs on different threads..it will intervened to operating system..
//something with a file working that pool will take care..
//once thw work is done..it trigger the call back for that work...
// this is all built in nodejs..
// event loop will started by nodejs..keeps nodejs process running..event loop handles only call backs..certain order..

//each loop iteration of event loop, checks that any "timer callbacks" is excute(setTimeout,setIntervals callbacks)....
// once completed "timercallback" checks next other callback("Pending callbacks")-- read or write file....IO typically is file operation , network operation(this all blocking long taking operation)..if its too long it will postpone to excute next iteration loop when it completes that read and write..nodejs will leave this phase moved to next callbacks or incoming request handling...
// now enter a poll phase -- where nodejs will look for "new IO events"---this callbacks excuted immediatly..if not posiible it will defer that excuetion ---register is an "pending callbacks"....it will always checks any "timer callbacks" excuetion and if ther jump to timers and excute that...
//after this move to "setImmediate callbacks"--excuted imeediatly but always after any "open callbacks" has been excuted... 
// after moved to end of each iteration cycle..now nodejs will excuete all "close event callbacks"...
//close events handles separtely or callbacks handles separtely..
//exit  the whole nodejs pgm only when no remaining event handlers which are registered....refs =null means can exit....
//nodejs keeps track of its "open event listener"..
//in server we create create server and keep listen, if didnt listen web server it will finshes once its done work...but in event it will never finished by default...therfore atleast 1 refs...soo we call the exit function..





//using the node modules system..  (by function is exported)



//creating new file for routes..

// const http =require('http');
// const routes=require('./backroutes');                                                       //import the routes.......since it is now not global module we just add local path (./)..can ignore (.js)-->because nodejs will add .js automatically at the end
//                                                                                             // after this it will look for "backroutes" file in the same floder "backnodebasis" will find and in that file look for module exports to see whats registered there...and can export "requestHandler" method..
// const server=http.createServer(routes);                // no--> routes() dont excuted it  so no paranthisis...only name-->(routes)..--> telling nodejs please execute the "function that stored in routes for incoming requests".....

//                                                        // file content cached by node and we cant edit externally....if routes an object and add a  new property---->routes.  --->  cant manipulate the original file...basical locked and not accessible from outside...we can only "export "stuff that we can read from outside                                                       
                                                         
// server.listen(3000) ; 


// output: hello+rahul  --> in message.txt vs code these will be print when we subit input throgh browser..





// 2nd way is export through object by access the handler property...



// const http =require('http');
// const routes=require('./backroutes');                                                       
//     console.log(routes.sometime);                                                                                  
// const server=http.createServer(routes.handler);                        // access the handler property...    
                                                                                                               
                                                         
// server.listen(3000) ; 


// output: Some hard coded text----> in vs code terminal..
//         hello+hii  --> when we submit in browser saved in file..in vs code file wat is there that will print...




 //3rd way of export by assign different property...

//  const http =require('http');
//  const routes=require('./backroutes'); 

//      console.log(routes.someText);                                                                                  
//  const server=http.createServer(routes.handler);                        // access the handler property...    
                                                                                                                
                                                          
//  server.listen(3000) ; 
 


//output: Some hard coded..... text----> in vs code terminal..
//        hello+rahul  --> when we submit in browser saved in file..in vs code file wat is there that will print...
 




//shortcut for 3rd way for export...


// const http =require('http');
//  const routes=require('./backroutes'); 

//      console.log(routes.someText);                                                                                  
//  const server=http.createServer(routes.handler);                        // access the handler property...    
                                                                                                                
                                                          
//  server.listen(3000) ; 



 //output: Some hard coded..... text----> in vs code terminal..
//        hello+hii+tt  --> when we submit in browser saved in file..in vs code file wat is there that will print...








// wrap up summary...


// > how the wed works..
  // client--> browser sends a request --> request to the server..
  // server--> it does reaches out database and works with files and send back a response
  // response-->the response can be html or different and send it back to the client..
  //client--> the browser which display that...
  
  //nodejs runs in non blocking way.. which means we only register a bunch of callbacks and events..nodejs will eventually trigger that code once certain task is done...so js thread will free to handle any incoming request or new events...and uses event drive code (event loop)-- for running logic..
  //node pgm exit as soon as there is no more work to do.....but in "createServer()" event never finshes by default.....if new event triggered , new rquest is recieved means this will not unregister the event listner, instead it keeps on listening for more requests...this like server behaves...
  //waiting for new events-->and dispatches some actions to the operating system-->frees up the thread..
  // dont send double response because asynchronous nature...code does not excute immdiately depends where u write code...if u write in event listner not excute immediatly...
  //  taken pic in mobile see and refer...






  //improved development worflow and debugging

  // module introduction


//debugging and easier development--- fixing errors, developing  efficiently..




//understanding NPM scripts..

//npm--> node package manger-- installed together with nodejs..
//can use  npm to initialize called node project..to add some extra features...
//pacakages are not included in nodes core...
//we use npm -to install some additional third party pacakages to our project...this pakages not nodes core modules..
//also use npm to initilize node project or some extra feature..
//vs terminal---> npm init---after this ask name and so on---
// if u dont pick name...the default showig terminal will take that file...//description u can u give anything...entry point u can choose u want any file...
// all saved to-->pacakage.json--> there u can edit tooo..
//this are the configuration file of u r project...
//this cofiguration file gives-->script section-->defaulty script not do anything now...
//u can add u r own new script....
//"start"-->special script name 

//"start":"node backNodeBasis.js"  --> then save it...
// run--> npm start
// it will excute the--->node backNodeBasis.js..

//u can add another script without using "start"-->special keyword...
//but give in double qoute and without whitespace and blanks...
//"start-server":"node backNodeBasis.js"..
// if u run--> npm start-server...--> will give error--- this typing the script name will not work...

//for normal scripts with thier own custom names--have to run -->npm run (script name)

// run---> npm run start-server---> will run --> node backNodeBasis.js------> this the way u can add u r own script...
//start -- is reserved key....it will look for start script...






// copy the  code which is backroutes.js-->save it run in terminal-->npm init

//code here

//then ask some question enter and ok..
//then ctrl c..

//write script in package.json in script section..
// "start":"node backNodeBasis.js"
//in terminal run--> npm start
//it excute nodeBasisBasis.js..


// clear terminal 

//add another script--"start-server":"node backNodeBasis.js" and save it---> will give error..because normal scripts with their own custom names --> run like---> npm run start-server
//excutes this scripts...







// installing 3rd party packages..


//if u had local project and u r code...and using some "core modules" like https...but it doest suffient..we use  "dependancy 3rd party"--> want use some functionality or code...
//pacakges could help u with "parsing incoming requests", "validating user input"...3rd party packages are express, body parser...so on..
//this pacakages in npm repository...
//that is cloud package repository....
//install and mange them via npm..
//3rd party install in vs terminal---> npm install nodemon .......--> auto-restart mechanism ->nodemon

// packages  install divided into "development and production dependencies"...pacakges helps running code or project js file on server...
// nodemon is development dependancy because use it in development process...because once we runs project code on server we dont need in server..

// in vs terminal-- "npm install nodemon --save"...> this is install production dependency..this use in package and use in our code..
// for..."npm install nodemon --save-dev"..> we used in during development...
//3rd option..."npm install nodemon -g"  --> we will not install in the project..but globally on our machine..

//download it from the npm repository and install into project..not global on machine..but in the project...
//it gives new things in project..and "node module floder" and "package lock.json" and updated the "pacakge.json" see in left side..in vs code..

//check in "pacakge.json" there devdependency is there..
// if we just "npm install"--> without mention extra pacakge name..it is command standalone...it will go throgh pacakage.json and install them and updated latest version if available...

//in node_modules floder...in that "nodemon" is there-->it is "source code of the pacakage" or" build version of the pacakge" we installed...see in that pacakge.json--> bunch of dependancy is installed..
//if u want free space delete node_modules floder..now u cant use that package but can rerun-->"npm install" if want start workng that project again...("start":"node backNodeBasis.js" , "start-server":"node backNodeBasis.js" )
//this how packages work in node projects.. 





//Global Features vs Core Modules vs Third-Party Modules




// Global features: Keywords like const or function but also some global objects like process

// Core Node.js Modules: Examples would be the file-system module ("fs"), the path module ("path") or the Http module ("http")

// Third-party Modules: Installed via npm install - you can add any kind of feature to your app via this way

// Global features are always available, you don't need to import them into the files where you want to use them.
// Core Node.js Modules don't need to be installed (NO npm install is required) but you need to import them when you want to use features exposed by them.

// Example:
// const fs = require('fs');
// You can now use the fs object exported by the "fs" module.
// Third-party Modules need to be installed (via npm install in the project folder) AND imported.

// Example (which you don't need to understand yet - we'll cover this later in the course):


// // In terminal/ command prompt
// npm install --save express-session
// // In code file (e.g. app.js)
// const sessions = require('express-session');






//using nodemon for autorestarts...


//wat is nodemon?

//Nodemon is a utility tool and it allows us to run our application, our node application" through this package " here which will run node backNodeBasis.js in the end but which will also watch our files for changes and restart the process for us if we do change something.
//if we change node to nodemon like---> "start":"nodemon backNodeBasis.js" in packages.json....it will look for nodemon tool in project ..because install here.. if u run "nodemon backNodeBasis.js" u will get error--> because not installed globally on machine only in project...
// locally means-- npm scripts will look for the "local version" of the pacakage..nodemon as a local dependency to our project here...

//run in terminal --> "npm start"--->nodemon will excute and node server..now automatically run when we save the file..

// if u changed something in code and saves it..this nodemon will automatically runs due to changes..so manually exit and start server no need..





//Global & Local npm Packages



//we added "nodemon" as a local dependency to our project.

//The good thing about local dependencies is that you can share projects without the node_modules folder (where they are stored) and you can run "npm install" in a project to then re-create that node_modules folder. This allows you to share only your source code, hence reducing the size of the shared project vastly.

// You could install nodemon globally if you wanted (this is NOT required though - because we can just run it locally): npm install -g nodemon would do the trick. Specifically the -g flag ensures that the package gets added as a global package which you now can use anywhere on your machine, directly from inside the terminal or command prompt.






// uderstanding different errors types.


//syntax errors, runtime errors, logical errors..


//finding and fixing syntax errors.

//syntax errors---it will show error before running or execute...like missing brackets or reserved key word spelling ...

//runtime errors---> it will excute but in terminal the output will throw error and in termial it shows wat is the error..(wat u coded doesnt working due to some mistake while excuetion)

//logical errors--->it is not cause an error message..but u will not get wat expected when coded..(the output is not coming as u expected or getting different output)...
 // debug: first run the pgm---> run debug---> select nodejs or "attach by Process Id"---> select u r file code written---->(debug attached--> show in terminal  and top box will come)-->mark the breakdown points-->and run browser for excution-->in vs code debug is showing one by one...where u want variable value--mark that line debug and go to debug cosole and enter that variable...it will show is there in that variable.....






 //using the debugger

//node does not excute line by line if it had callback it will register callback and excute in future and jump to another block...once that operation finished .the call back will excute...




//restarting the debugger automatically after editing our backNodeBasis.js..

//2 things --- one is break point of debug..
//             second  is u can console in debug console..which u used in code..
  //           u can try and error different code in the debug console...it will not affect that real code..u can check here and try before adding that into real code.. 

// // it will give error while debugging in terminal because it will not use local nodemon..it looks for globally..so run --- "npm install nodemon -g " 

//after install to globally..now click run deubg and u can it..this will  run in  terminal..
// add breakpoint..and run browser and subit name... now u see the output in terminal..
//but also u can debug console to check variable value..in terminal u will get normal output..
// u have to use "terminal"---> because if u change anything and save the code... both debugger and node restarts---this are "2 separate processes"..
//if u want stop the debugger..nodemon has quit separtely or exit separtly---u can do by--"control c"--->this will not be done in "debug console"--this y funnel this in terminal..
//u stop processes separetly..u can do it from terminal..if u r using "nodemon process"--should use "integratedTerminal"...






//changing variables in the debug console


//when u in debug state..u can edit the variable value by double click there on left side of vs code....
//and "resume" the debug and now debug finished...go to file check there u will get the value wat u edited...  

















// Expressjs



//introduction..


// in expressjs u dont want care like handling incoming requests or routing...
//this frameworks can install-- 3rd party pacakage in node project...
// gives lot of utility functions..
//express is buit around middleware..


// what is express.js


//writing all that server side logic is pretty complex--- as we do parse in coming request, extracting body and manually listen the data eventand end event, create buffer and converting string..// if u have file to working u want write code..express will help in that case..
//does not to have built in handling or parsing but it makes easy to install another package...--> can easliy hooked in project..
//framework--> is basically a set of helper functions , which had rules ans tools we work..
// in this vanilla nodejs used..
// express is highly flexible and doesnt add too much functionalities out of the box..




// installing express.js





// const http =require('http');
   
// const express = require('express');               // import express to use it..

// const app = express();                             // to store express in variable to running express as function.. or we can tell--> the express package seems to export a function in the end..   

// const server=http.createServer(app);                          
                                                                                                               
                                                         
// server.listen(3000) ;            

                             // run "npm install --save"  because this is production dependency..we dont use that as a tool during developing....it will be an intergral part of the application we ship..so installed..
                             // on any server or any computer we run our application once we depoly it..
                             // "npm install --save"--production dependancy..."express" -- name of the package...
                             // soo run "npm install --save express"    

//output: run "npm start".....>this will not handle any requests because have not defined any logic that happen for incoming requests...                              
                                  // this sets up a certain way handling incoming requests that defines..or key characteristics of expressjs...




//  adding middleware



//middleware means that an incoming request is automatically funneled through a bunch of functions by expressjs..
// so request handler hooking in multiple function..
// this request will go till u send response..




// const http =require('http');
   
// const express = require('express');               // import express to use it..

// const app = express();                             // to store express in variable to running express as function.. or we can tell--> the express package seems to export a function in the end..   

// app.use((req,res, next)=> {          // for every incoming reuest this function willl excute.                           // (.use)--> method defined by express framework..this "use" allow to add new middleware function..
// console.log('in the middleware')
//                                            //next is function this will passed to this function by expressjs....this "will allow the request to travel on to the next middleware"..
// }); 
// const server=http.createServer(app);                          
                                                                                                               
                                                         
// server.listen(3000) ; 

//output: run--> "npm start"
        //run browser--> it will just keep loading or spinning- not get response--> because we got no logic where we send one....
        // in console ---> "in the middleware"    ===because allows to excute hook into funnel through request is sent...




 // if i duplicate and add another use statement..
 
 




// const http =require('http');
   
// const express = require('express');               // import express to use it..

// const app = express();                             // to store express in variable to running express as function.. or we can tell--> the express package seems to export a function in the end..   

// app.use((req,res, next)=> {          // for every incoming reuest this function willl excute.                           // (.use)--> method defined by express framework..this "use" allow to add new middleware function..
// console.log('in the middleware')
//                                            //next is function this will passed to this function by expressjs....this "will allow the request to travel on to the next middleware"..

// next();                                      // if u didnt call "next"--> next just dies and if didnt call-->we should" send back a response" because otherwise the request cant continue its journey..

// }); 

// app.use((req,res, next)=> {          // for every incoming reuest this function willl excute.                           // (.use)--> method defined by express framework..this "use" allow to add new middleware function..
//   console.log('in another  middleware')
//                                              //next is function this will passed to this function by expressjs....this "will allow the request to travel on to the next middleware"..
//   }); 


// const server=http.createServer(app);                          
                                                                                                               
                                                         
// server.listen(3000) ; 
                                                //"next()"-->this allows the request to continue to the next middleware in..

//output:  in the middleware
     //    in another  middleware





// how middleware works...  



// const http =require('http');
   
// const express = require('express');               // import express to use it..

// const app = express();                             // to store express in variable to running express as function.. or we can tell--> the express package seems to export a function in the end..   

// app.use((req,res, next)=> {          // for every incoming reuest this function willl excute.                           // (.use)--> method defined by express framework..this "use" allow to add new middleware function..
// console.log('in the middleware')
//                                            //next is function this will passed to this function by expressjs....this "will allow the request to travel on to the next middleware"..

// next();                                      // if u didnt call "next"--> next just dies and if didnt call-->we should" send back a response" because otherwise the request cant continue its journey..

// }); 

// app.use((req,res, next)=> {          // for every incoming reuest this function willl excute.                           // (.use)--> method defined by express framework..this "use" allow to add new middleware function..
//   console.log('in another  middleware')
//                                              //next is function this will passed to this function by expressjs....this "will allow the request to travel on to the next middleware"..
//                                             // we should send response ...response object sending response...or u can setting header...
//   res.send('<h1>Hello from Express!</h1>');                                          // new utility function  we can send...(.send)--> allows to send response...can attach a body any type..here i use html
  
//   });                                                    // see the browser inspect the content type automatically set to : text/html---> this feauture provided by expressjs
//                                                           //default response header is : text/html.....
//                                                          // here request is not died because we are sending response with "send"
// const server=http.createServer(app);                          
                                                                                                               
                                                         
// server.listen(3000) ; 
 

//output: when u run browser u will get---> "Hello from Express!"
   //terminal: in the middleware
             // in another  middleware



// Express.js-looking behind the scenes....



//in github-->expressjs-->select (lib)--->select (responsejs)--- analyse code--->then come back-->select (applicationjs)--> analyse code search for listen and review..



// u can eliminte "http" module and "createserver" and that line like below..




   
// const express = require('express');               // import express to use it..

// const app = express();                             // to store express in variable to running express as function.. or we can tell--> the express package seems to export a function in the end..   

// app.use((req,res, next)=> {          // for every incoming reuest this function willl excute.                           // (.use)--> method defined by express framework..this "use" allow to add new middleware function..
// console.log('in the middleware')
//                                            //next is function this will passed to this function by expressjs....this "will allow the request to travel on to the next middleware"..

// next();                                      // if u didnt call "next"--> next just dies and if didnt call-->we should" send back a response" because otherwise the request cant continue its journey..

// }); 

// app.use((req,res, next)=> {          // for every incoming reuest this function willl excute.                           // (.use)--> method defined by express framework..this "use" allow to add new middleware function..
//   console.log('in another  middleware')
//                                              //next is function this will passed to this function by expressjs....this "will allow the request to travel on to the next middleware"..
//                                             // we should send response ...response object sending response...or u can setting header...
//   res.send('<h1>Hello from Express!</h1>');                                          // new utility function  we can send...(.send)--> allows to send response...can attach a body any type..here i use html
  
//   });                                                    // see the browser inspect the content type automatically set to : text/html---> this feauture provided by expressjs
//                                                           //default response header is : text/html.....
//                                                          // here request is not died because we are sending response with "send"
// app.listen(3000);


//output: in browser runs "hello expressjs"---> by express framework..
    //terminal: in the middleware
             // in another  middleware









//assignment --> res.send("( { key1: value })")







// const express = require('express');               // import express to use it..

// const app = express();                             // to store express in variable to running express as function.. or we can tell--> the express package seems to export a function in the end..   

// app.use((req,res, next)=> {          // for every incoming reuest this function willl excute.                           // (.use)--> method defined by express framework..this "use" allow to add new middleware function..
// console.log('in the middleware')
//                                             //next is function this will passed to this function by expressjs....this "will allow the request to travel on to the next middleware"..

//  next();                                      // if u didnt call "next"--> next just dies and if didnt call-->we should" send back a response" because otherwise the request cant continue its journey..

//  }); 

//  app.use((req,res, next)=> {          // for every incoming reuest this function willl excute.                           // (.use)--> method defined by express framework..this "use" allow to add new middleware function..
//    console.log('in another  middleware')
//                                              //next is function this will passed to this function by expressjs....this "will allow the request to travel on to the next middleware"..
//                                             // we should send response ...response object sending response...or u can setting header...
//   res.send({key1: value});                                          // new utility function  we can send...(.send)--> allows to send response...can attach a body any type..here i use html
  
//   });                                                    // see the browser inspect the content type automatically set to : text/html---> this feauture provided by expressjs
//                                                           //default response header is : text/html.....
//                                                          // here request is not died because we are sending response with "send"
// app.listen(3000);



// output: text/html






//   yash video

// const arr= [1,2,3]

// const b= arr.map(elem => elem * 2)    

// console.log(b);


//output: [2,4,6]


// within the "curl braces use return "


// const arr= [1,2,3]

// const b= arr.map(elem =>{ 
//    return elem * 2
// })    

// console.log(b);

//output: [2,4,6]






// handling different routes..



// should only trigger for requests that go--> "/"

// const express = require('express');                      
// const app = express(); 

// app.use('/', (req,res, next)=> {                                       // five arguments ways to use this -->.use method....(path,callback)....path --> used to filrter out certain request 
//    console.log('in another  middleware!');
                                                                                    
//      res.send('<h1>Hello from Express!</h1>');                                          
    
//      });                                                   
                                                             
                                                            
//    app.listen(3000);

   // output: Hello from Express!
  // in terminal: in another  middleware!
             //   in another  middleware!



   // if u run the browser--> http://localhost:3000/add-product


   // output: Hello from Express!              --> same output
   
   // in terminal: in another  middleware!
             //    in another  middleware!




//specific telling "/add-product" to match url..




// const express = require('express');                      
// const app = express(); 

// app.use('/add-product', (req,res, next)=> {                                    // adding another duplicate middleware          
//   console.log('in another  middleware!');
                                                                                   
//     res.send('<h1>The "Add Product" Page</h1>');                                          
   
//     });                                                   
         
// app.use('/', (req,res, next)=> {                                       
//    console.log('in another  middleware!');
                                                                                    
//      res.send('<h1>Hello from Express!</h1>');                                          
    
//      });                                                   
                                                             
                                                            
//    app.listen(3000);                                         
//                                                        // this is the code that allows us to route our requests into different middleware...


   //  output: when run url--> http://localhost:3000     or  http://localhost:3000/ ---> Hello from Express!

  //                        --> http://localhost:3000/add-product   ---> The "Add Product" Page

 // in terminal: in another  middleware!
          //     in another  middleware!                                                           



 

 // and we have middleware that should be applied to all "request"--> we simoly add on to top of all other middleware..
 
 


//  const express = require('express');                      
// const app = express(); 


// app.use('/', (req,res,next)=>{                                     // u can add specific filter to match or without filter -->"/"
// console.log('This always runs!');                                // this middleware appiled all the request
// next();                                                         // contiuesd to after this..
// })


// app.use('/add-product', (req,res, next)=> {                                    // adding another duplicate middleware          
//   console.log('in another  middleware!');
                                                                                   
//     res.send('<h1>The "Add Product" Page</h1>');                                          
   
//     });                                                   
         
// app.use('/', (req,res, next)=> {                                       
//    console.log('in another  middleware!');
                                                                                    
//      res.send('<h1>Hello from Express!</h1>');                                          
    
//      });                                                   
                                                             
                                                            
//    app.listen(3000);        


//output: when run url--> http://localhost:3000     or  http://localhost:3000/ ---> Hello from Express!

  //                        --> http://localhost:3000/add-product   ---> The "Add Product" Page


// in terminal: This always runs!
//              in another  middleware!





// parsing incoming requests..           --> work with incoming requests and extract data...

// for this i want handle post request


// const express = require('express');                      
// const app = express(); 


// app.use('/add-product', (req,res, next)=> {                                             
                                                                                   
//     res.send('<form action ="/product" method="POST"><input type="text" name="title"><button type="submit">Add Product</button></form>');              // here i want return html page with a form                            
   
//     });                                                                           // this will send html back which holds form---> so we need a "route" or "middleware" that handles requests to product
         
// app.use('/product', (req, res, next)=>{
//   console.log(req.body);                                      //geeting the body of incoming request...extract the wat the user has sent me
//   res.redirect('/');                                                    // redirect method provided by express--> instead of manually setting the status codeand location header

// })

// app.use('/', (req,res, next)=> {                                       
                                                                                    
//      res.send('<h1>Hello from Express!</h1>');                                          
    
//      });                                                   
                                                             
                                                            
//    app.listen(3000);        



//output: run --> http://localhost:3000/add-product   --> form will come and give input --> type "book" and submit
// redirected to -->http://localhost:3000/----> Hello from Express! ---> we redirected "/"

// in terminal --> "undefined"-----> for console.log(req.body)..--- reuest gives this body property by default..but request "does not try to parse the incoming request body" 
                // to do that we need to register a parser and.... we do that adding "another middleware"
     
               
 //  to add another middleware we need do that before u r route handling middleware .. because prasing of the body should be done...no matter where u r request ends..u want prase the incoming request body first...for that install 3rd party package..run--> "npm install --save body-parser".. 




// parse the incoming requests.. the body before  route handling middleware...


// const express = require('express');
// const bodyParser = require('body-parser');               // package of body praser

// const app = express(); 

// app.use(bodyParser.urlencoded({extended:false}));                               // use that object bodyparser and .urlencoded()... this .urlencoded() is a function to execute...this register middleware---> "bodyParser.urlencoded()"-->is middleware......urlencoded yelids a middleware function-->(req,res, next)=>{ console.log(req.body); res.redirect('/');}--> we cant see that...
//                                                        // this not parese all kinds possible bodies, files,json...but will parse bodies like the we getting..sent through a form



// app.use('/add-product', (req,res, next)=> {                                             
                                                                                   
//     res.send('<form action ="/product" method="POST"><input type="text" name="title"><button type="submit">Add Product</button></form>');              // here i want return html page with a form                            
   
//     });                                                                           // this will send html back which holds form---> so we need a "route" or "middleware" that handles requests to product
         
// app.use('/product', (req, res, next)=>{
//   console.log(req.body);                                      //getting the body of incoming request...extract the wat the user has sent me
//   res.redirect('/');                                                    // redirect method provided by express--> instead of manually setting the status codeand location header

// })

// app.use('/', (req,res, next)=> {                                       
                                                                                    
//      res.send('<h1>Hello from Express!</h1>');                                          
    
//      });                                                   
                                                             
                                                            
//    app.listen(3000);    



  // output: run interminal:  "npm install --save body-parser"  ----->3rd party package for prasing incoming request body....this matter use "production" so -->--save..
  //  now u can use this method "prase body"
  // while error came:-->body-parser deprecated undefined extended: provide extended option..
  // give like config option for urlencoded--> app.use(bodyParser.urlencoded({extended:false}));------> this should able to parse non-default features... 
  
  // run --> http://localhost:3000/add-product   --> form will come and give input --> type "book" and submit..
  // redirected to -->http://localhost:3000/----> Hello from Express! ---> we redirected "/"

 // in terminal:   { title: 'book' }         // javascript object--> key and value pair format....key we defined in html (input:-->name: "title") and the value user entered.....now we can work with that data user entered... store it in database or showing in response...

      //now able to parse incoming request bodies with the help of the body parser package....









 // limiting middleware execution to POST requests...



//  const express = require('express');
// const bodyParser = require('body-parser');               // package of body praser

// const app = express(); 

// app.use(bodyParser.urlencoded({extended:false}));                               // use that object bodyparser and .urlencoded()... this .urlencoded() is a function to execute...this register middleware---> "bodyParser.urlencoded()"-->is middleware......urlencoded yelids a middleware function-->(req,res, next)=>{ console.log(req.body); res.redirect('/');}--> we cant see that...
//                                                                                 // this not parese all kinds possible bodies, files,json...but will parse bodies like the we getting..sent through a form



// app.use('/add-product', (req,res, next)=> {                                             
                                                                                   
//     res.send('<form action ="/product" method="POST"><input type="text" name="title"><button type="submit">Add Product</button></form>');                            // here i want return html page with a form                            
   
//     });                                                                                                                                                             // this will send html back which holds form---> so we need a "route" or "middleware" that handles requests to product
         

// // app.use('/product', (req, res, next)=>{                        // but this miiddleware alwaays excuted  not just "Post requests" but also for "GET requests".
// //   console.log(req.body);                                                                                                                                           //geeting the body of incoming request...extract the wat the user has sent me
// //   res.redirect('/');                                                                                                                                               // redirect method provided by express--> instead of manually setting the status codeand location header

// // })


// //soo instead of -->app.use() above middleware we use --->app.get() 


// app.get('/product', (req, res, next)=>{                                 // this -->"app.use()"-->it only will fire for incoming get requests--another form of filtering besides filtering for path.....this-->app.get--> allows us to filter for "get requests"..
// console.log(req.body);                                                  // u can use another form filtering..-->"app.post()"-->to filter for "incoming post request"
// res.redirect('/');   
// })


// // or we can use "app.post()" instead of "app.get" like below...

// // app.post('/product', (req, res, next)=>{                                 //"app.post()"-->to filter for "incoming post request"....soo this middleware will now only trigger for "incoming post requests" with that "path" which u gave inside, here-->'/product'
// //   console.log(req.body);
// //   res.redirect('/');
// // })
//                                                                           // can use--different http methods like--> .delete, .put, .patch...

// app.use('/', (req,res, next)=> {                                       
                                                                                    
//      res.send('<h1>Hello from Express!</h1>');                                             
    
//      });                                                   
                                                                                                                     
// app.listen(3000);    

// for using "app.post()" output below:

//output: run in browser: http://localhost:3000/product----> u will get --> Hello from Express!--->so here didnt end up even i entered /product but it was "get request"....but if u send post request through that form--> u will see the output in terminal-->{title:'book 2'}
//      then run --> http://localhost:3000/add-product  --> u will get---->form to input and submit -->type "book 2"---> u will get --> Hello from Express!...in terminal u wil get--> { title: 'book 2' }..
                                                         

// for using "app.get()" output below and uncommented or removed app.post():


//output: run in browser: http://localhost:3000/product----> u will get --> Hello from Express!
//        then run --> http://localhost:3000/add-product  --> u will get---->form to input and submit -->type "book 2" ---> u will get --> Hello from Express!---> in terminal" not get output u entered" because u r using "app.get()"-->the browser stand end with this link-->  http://localhost:3000/product---> it will stops in  second "app.get()" middleware itself..








//assignment adding another tag in input like size and prase both input..


// const express = require('express');
// const bodyParser = require('body-parser');               

// const app = express(); 

// app.use(bodyParser.urlencoded({extended:false}));                              
                                                                              



// app.use('/add-product', (req,res, next)=> {                                             
                                                                                   
//     res.send('<form action ="/product" method="POST"><input type="text" name="title"><input type="number" name="size"><button type="submit">Add Product</button></form>');                            // here i want return html page with a form                            
   
//     });                                                                                                                                                             // this will send html back which holds form---> so we need a "route" or "middleware" that handles requests to product
         

//  app.use('/product', (req, res, next)=>{                       
//    console.log(req.body);                                                                                                                                           //geeting the body of incoming request...extract the wat the user has sent me
//    res.redirect('/');                                                                                                                                               // redirect method provided by express--> instead of manually setting the status codeand location header

//  })


 //soo instead of -->app.use() above middleware we use --->app.get() 


// app.get('/product', (req, res, next)=>{                                 
// console.log(req.body);                                                  
// res.redirect('/');   
// })


// // or we can use "app.post()" instead of "app.get" like below...

// // app.post('/product', (req, res, next)=>{                                 
// //   console.log(req.body);
// //   res.redirect('/');
// // })
//                                                                           

// app.use('/', (req,res, next)=> {                                       
                                                                                    
//      res.send('<h1>Hello from Express!</h1>');                                             
    
//      });                                                   
                                                                                                                     
// app.listen(3000);    


// output: run --> http://localhost:3000/add-product  --> u will get---->form to input and submit -->type "book" and size: 3 ---> u will get --> Hello from Express!..
//     in terminal u wil get--> { title: 'book', size: '3' }..







// using Express Router


// const express = require('express');
// const bodyParser = require('body-parser');               

// const app = express(); 

// const  adminRoutes=require('./routes/admin')                   // using a relative path to the routes folder...

// const shopRoutes=require('./routes/shop')           // import of shop js for front face router access


// app.use(bodyParser.urlencoded({extended:false}));                              
                                                                                                                                                   

// app.use(adminRoutes);                 // registering   1st      // this is a middleware of 2 routes we are importing                // not like function->adminRoutes() without parenthisis...but just object--->"adminRoutes"
// app.use(shopRoutes)                            //registering 2nd 
                                                                                                           
// app.listen(3000);    


// spilt routing code
//export our logic in different files and import it into this file
//routes of -add-product and product will move to admin .js and normal route user visting front facing will see that will go shop.js....


//output: "npm start"   
       // load --> http://localhost:3000/add-product----> form will come to submit..and end with-->http://localhost:3000/add-product





  // come to backNodeBasis.js--> switch the register 2nd to 1st and 1st to second --->   app.use(shopRoutes)
     //                                                                                  app.use(adminRoutes); 


// const express = require('express');
// const bodyParser = require('body-parser');               

// const app = express(); 

// const  adminRoutes=require('./routes/admin')                   // using a relative path to the routes folder...

// const shopRoutes=require('./routes/shop')           // import of shop js for front face router access


// app.use(bodyParser.urlencoded({extended:false}));                              
                                                                                                                                                   

// app.use(shopRoutes);                        //   adminRoutes --> shopRoutes                                           // registering   1st      // this is a middleware of 2 routes we are importing                // not like function->adminRoutes() without parenthisis...but just object--->"adminRoutes"
// app.use(adminRoutes)                       //    shopRoutes--->  adminRoutes                                         //registering 2nd 
                                                                                                           
// app.listen(3000);    




// output:  after switch of order of excuetion
//          run--> in browser --> http://localhost:3000/add-product----> form will come to submit..and end with -->http://localhost:3000/add-product....                       // we did not end up in "shop.js" route--->(because form will come..form in admin.js) because i had "Get"--> in shop.js..because "Get" and "Post" both are do actually exact match->('/')...if we run "app.get" or "app.post" both will get form in browser and end up with-->http://localhost:3000/add-product.  
                 //                                                                                                                                                              if we did--> "router.use()" in (shop.js)--> and run in browser reload--> will get---> "hello from express"....and end with-->http://localhost:3000/add-product..

               // after this do below 
                 // and run random request--->like-->http://localhost:3000/hhghddj....--> u will get error--> "Cannot GET /hhghddj"...because i dont have single middleware to handle...




                 


//  adding a 404 error page...                



// const express = require('express');
// const bodyParser = require('body-parser');               

// const app = express(); 

// const  adminRoutes=require('./routes/admin')                   // using a relative path to the routes folder...

// const shopRoutes=require('./routes/shop')                      // import of shop js for front face router access


// app.use(bodyParser.urlencoded({extended:false}));                              
                                                                                                                                                   
 
// app.use(adminRoutes);                                                                                // registering   1st      // this is a middleware of 2 routes we are importing                // not like function->adminRoutes() without parenthisis...but just object--->"adminRoutes"
// app.use(shopRoutes)                                                                              //registering 2nd 
                 
// app.use((req,res,next)=>{                              // this will handle error middleware                // by default it will be '/'--> no need to put...
//   res.status(404).send('<h1>Page not found</h1>');                                  // .status(404)-->method given by express 
// });



// app.listen(3000);    
                                             //.use()--> will handle all types of http methods..


// output: in browser run--> http://localhost:3000/hhghddj--> u will get--> Page not found.. and end up with -->http://localhost:3000/hhghddj  
//               then  run-->  http://localhost:3000/add-product----> form will come..and endup with-->http://localhost:3000/add-product...       







//filtering paths...



// const express = require('express');
// const bodyParser = require('body-parser');               

// const app = express(); 

// const  adminRoutes=require('./routes/admin')                   // using a relative path to the routes folder...

// const shopRoutes=require('./routes/shop')                      // import of shop js for front face router access


// app.use(bodyParser.urlencoded({extended:false}));                              
                                                                                                                                                   
 
// app.use('/admin', adminRoutes);                                               // we add common path for each router in admin.js-->'/admin/add-product' and in form action also change-->/product to /add-project--> or change in app.js itself 1 time --> ('/admin', adminRoutes)...like this line..                                                       // registering   1st      // this is a middleware of 2 routes we are importing                // not like function->adminRoutes() without parenthisis...but just object--->"adminRoutes"
// app.use( shopRoutes)                                                                              //registering 2nd 
                 
// app.use((req,res,next)=>{                                                      // this will handle error middleware                // by default it will be '/'--> no need to put...
//   res.status(404).send('<h1>Page not found</h1>');                                  // .status(404)-->method given by express 
// });



// app.listen(3000);                                   
                                            // so segment as filter, now router starts with /admin will go into the adminRoutes file..
                                                    

// output: run browser--> http://localhost:3000/add-product----> will get-->"Page not found"---> because not exiting...
 // now run browser--->http://localhost:3000/admin/add-product---> will get form to type and submit-->"book", 3- and submit--> u will get-->"Page not found"...and end up with-->http://localhost:3000/product..--because in admin.js --form action is "/product"..soo change to /admin/product---> because i want redirect to /product next route.. to get--> "hello from express".....
 //                                                                after changing in form action--> run and form will come and type and submit.--> u will get-->"Hello from Express!"..--> u will endup with-->http://localhost:3000/...

 // in terminal u will get: { title: 'book', size: '2' }...

// this filtering allow us to put common starting segment for our path...






// assignment--> make a /shop route for all the routes that call the shop.js file...





// const express = require('express');
// const bodyParser = require('body-parser');               

// const app = express(); 

// const  adminRoutes=require('./routes/admin')                   // using a relative path to the routes folder...

// const shopRoutes=require('./routes/shop')                      // import of shop js for front face router access


// app.use(bodyParser.urlencoded({extended:false}));                              
                                                                                                                                                   
 
// app.use('/admin', adminRoutes);                                               // we add common path for each router in admin.js-->'/admin/add-product' and in form action also change-->/product to /add-project--> or change in app.js itself 1 time --> ('/admin', adminRoutes)...like this line..                                                       // registering   1st      // this is a middleware of 2 routes we are importing                // not like function->adminRoutes() without parenthisis...but just object--->"adminRoutes"
// app.use(shopRoutes)                                                                              //registering 2nd 
                 
// app.use((req,res,next)=>{                                                      // this will handle error middleware                // by default it will be '/'--> no need to put...
//   res.status(404).send('<h1>Page not found</h1>');                                  // .status(404)-->method given by express 
// });



// app.listen(3000); 


//output: changed to "/shop"-->in "admin.js"--> in 2nd route because it calls shop.js....and shop.js -->changed to "/shop" in the route ..
//         in browser run-->http://localhost:3000/admin/add-product-->type and submit -->u will get--> Hello from shop!--> and endup with -->http://localhost:3000/shop..
//          in terminal-->{ title: 'book', size: '3' }..






//  creating HTML pages

//views-->bunch of html file



// serving html pages..

// const express = require('express');
// const bodyParser = require('body-parser');               

// const app = express(); 

// const  adminRoutes=require('./routesHtmlCss/adminHtmlCss')                   // using a relative path to the routes folder...

// const shopRoutes=require('./routesHtmlCss/shopHtmlCss')                      // import of shop js for front face router access


// app.use(bodyParser.urlencoded({extended:false}));                              
                                                                                                                                                   
 
// app.use('/admin', adminRoutes);                                                                                // registering   1st      // this is a middleware of 2 routes we are importing                // not like function->adminRoutes() without parenthisis...but just object--->"adminRoutes"
// app.use(shopRoutes);                                                                             //registering 2nd 
                 
// app.use((req,res,next)=>{                              // this will handle error middleware                // by default it will be '/'--> no need to put...
//   res.status(404).send('<h1>Page not found</h1>');                                  // .status(404)-->method given by express 
// });



// app.listen(3000);



//output: run--> localhost:3000/---> will come contents
   //     run-->localhost:3000/admin/add-product----> will come content






   //returning a 404 page...


  // add 404.html in views floder....and return html file..--> so add file path in main file-->backNodeBasis.js..




//  const path=require('path');

// const express = require('express');
// const bodyParser = require('body-parser');               

// const app = express(); 

// const  adminRoutes=require('./routesHtmlCss/adminHtmlCss')                   // using a relative path to the routes folder...

// const shopRoutes=require('./routesHtmlCss/shopHtmlCss')                      // import of shop js for front face router access


// app.use(bodyParser.urlencoded({extended:false}));                              
                                                                                                                                                   
 
// app.use('/admin', adminRoutes);                                                                                // registering   1st      // this is a middleware of 2 routes we are importing                // not like function->adminRoutes() without parenthisis...but just object--->"adminRoutes"
// app.use(shopRoutes);                                                                             //registering 2nd 
                 
// app.use((req,res,next)=>{                                                 // this will handle error middleware                // by default it will be '/'--> no need to put...
//   res.status(404).sendFile(path.join(__dirname, 'views', '404.html'));     // we dont need to put(../)--> because we already are in the root folder...                                // .status(404)-->method given by express 
// });



// app.listen(3000);



//output: run random url-->http://localhost:3000/admin/add-productdkdkk
 // will display -->Page Not Found!





 // deprecation warning --->use--->"module.exports = path.dirname(require.main.filename);"





 //using a helper function for navigation..


// use--->"(..)"...instead(../)
// in "adminHtmlCss.js"  and "shopHtmlCss.js"


//output: it will run---> http://localhost:3000/admin/add-product
// it will work and showed contect...and we can also it with the help og parent directory..





//we can get parent directory with the help of helper function...       this method will work all os..

//create folder as "util" ---> then inside this create ---> "path.js" and also import this in adminhtmlcss and shophtmlcss 



// const path=require('path');

// const express = require('express');
// const bodyParser = require('body-parser');               

// const app = express(); 

// const  adminRoutes=require('./routesHtmlCss/adminHtmlCss')                   // using a relative path to the routes folder...

// const shopRoutes=require('./routesHtmlCss/shopHtmlCss')                      // import of shop js for front face router access


// app.use(bodyParser.urlencoded({extended:false}));                              
                                                                                                                                                   
 
// app.use('/admin', adminRoutes);                                                                                // registering   1st      // this is a middleware of 2 routes we are importing                // not like function->adminRoutes() without parenthisis...but just object--->"adminRoutes"
// app.use(shopRoutes);                                                                             //registering 2nd 
                 
// app.use((req,res,next)=>{                                                 // this will handle error middleware                // by default it will be '/'--> no need to put...
//   res.status(404).sendFile(path.join(__dirname, 'views', '404.html'));     // we dont need to put(../)--> because we already are in the root folder...                                // .status(404)-->method given by express 
// });



// app.listen(3000);


// output: run -->http://localhost:3000/----> it will content 






//styling our pages....

  
// const path=require('path');

// const express = require('express');
// const bodyParser = require('body-parser');               

// const app = express(); 

// const  adminRoutes=require('./routesHtmlCss/adminHtmlCss')                   // using a relative path to the routes folder...

// const shopRoutes=require('./routesHtmlCss/shopHtmlCss')                      // import of shop js for front face router access


// app.use(bodyParser.urlencoded({extended:false}));                              
                                                                                                                                                   
 
// app.use('/admin', adminRoutes);                                                                                // registering   1st      // this is a middleware of 2 routes we are importing                // not like function->adminRoutes() without parenthisis...but just object--->"adminRoutes"
// app.use(shopRoutes);                                                                             //registering 2nd 
                 
// app.use((req,res,next)=>{                                                 // this will handle error middleware                // by default it will be '/'--> no need to put...
//   res.status(404).sendFile(path.join(__dirname, 'views', '404.html'));     // we dont need to put(../)--> because we already are in the root folder...                                // .status(404)-->method given by express 
// });



// app.listen(3000);



//output:run-->http://localhost:3000/---> content will come--->click on add product -->type "book"---> and click "add product" button.
//            in vs terminal ---> { title: 'book' }--> will come...





// serving files statically..

                            
                                             // we need a feauture expressjs -->need to be able to serve files statically-->statically means--> not handled by the express router or other middleware --> "it directly forwarded to the file system"
                                             



                                              


                                              //this is handled by the static middleware..forward the request the public folder..

// const path=require('path');

// const express = require('express');
// const bodyParser = require('body-parser');               
                                              
// const app = express(); 
                                              
// const  adminRoutes=require('./routesHtmlCss/adminHtmlCss')                   // using a relative path to the routes folder...
                                              
//  const shopRoutes=require('./routesHtmlCss/shopHtmlCss')                      // import of shop js for front face router access
                                              
 
// app.use(bodyParser.urlencoded({extended:false}));  
                         
// app.use(express.static(path.join(__dirname, 'public')));                                              // register new middleware -->app.use-->this will ship by "expressjs"...this does had static method and ".static"---> is built in middleware---> it serves "static files."......//only read access                                                                                                                                                          
                                               
//  app.use('/admin', adminRoutes);                                                                                // registering   1st      // this is a middleware of 2 routes we are importing                // not like function->adminRoutes() without parenthisis...but just object--->"adminRoutes"
// app.use(shopRoutes);                                                                             //registering 2nd 
                                                               
// app.use((req,res,next)=>{                                                     // this will handle error middleware                // by default it will be '/'--> no need to put...
//  res.status(404).sendFile(path.join(__dirname, 'views', '404.html'));         // we dont need to put(../)--> because we already are in the root folder...                                // .status(404)-->method given by express 
//  });
                                              
                                              
                                              
//  app.listen(3000);                                              




                                             // create "public" floder--->inside "css" floder--->inside "main.css" floder stylesheet..
                                             // shop.html-->copy of style code into this folder "main.css" and in "shop.html"--> add "link rel=stylesheet"...
                                             // construct path for serve static files-->    "express.static(path.join(__dirname, 'public'))""
                                              // add "link rel=stylesheet"-->in "add-product.html"..remove css code in .html...and do same in 404.html...



//output: :run-->http://localhost:3000/---> content will come--->click on add product -->type "book"---> and click "add product" button.
//            in vs terminal ---> { title: 'book' }--> will come...
// here we  access css file in separete folder..








 // summary  

 // what is expressjs?

 // expressjs is nodejs framework--> a package that adds a bunch of utility functions and tools and a clear set of rules on how the app should be built (middleware)..
 // its highly extensible and other packages can be plugged into it (middleware)..  


 //middleware, next() and res()

 //express.js relies heavily on middleware functions--u can easily add them by calling use()...
 //middleware functions handle a request and should call next() to forward the request to the next function in line or send a response..
 

 //routing 

 // u can filter requests by path and method..
 //if u filter by method, paths are matched exactly, otherwise the first segment of a URL is matched.
 //u can use the express.Router() to split u r routes across files elegantly...


 // Serve files 

 // can serving dummy text as a response..
 // u can sendFile()s to u r users-- eg: HTML files..
 //if a request is directly made for a file (eg: a  ".css" files is registed) u can enable static serving for such files via express.static()..
 



 // assignment


 const path=require('path');

 const express = require('express');
 const bodyParser = require('body-parser');               
                                               
 const app = express(); 
                                               
 const  adminRoutes=require('./routesHtmlCss/adminHtmlCss')                   // using a relative path to the routes folder...
                                               
const shopRoutes=require('./routesHtmlCss/shopHtmlCss')                      // import of shop js for front face router access
                                               
const contactRoutes=require('./routesHtmlCss/contactUs'); 

const successRoutes=require('./routesHtmlCss/successful');

 app.use(bodyParser.urlencoded({extended:false}));  
                          
 app.use(express.static(path.join(__dirname, 'public')));                                              // register new middleware -->app.use-->this will ship by "expressjs"...this does had static method and ".static"---> is built in middleware---> it serves "static files."......//only read access                                                                                                                                                          
                                                
  app.use('/admin', adminRoutes);                                                                                // registering   1st      // this is a middleware of 2 routes we are importing                // not like function->adminRoutes() without parenthisis...but just object--->"adminRoutes"
 app.use(shopRoutes); 
 app.use('/admin', contactRoutes); 
 app.use('/admin', successRoutes);                                                                            //registering 2nd 
                                                                
 app.use((req,res,next)=>{                                                     // this will handle error middleware                // by default it will be '/'--> no need to put...
  res.status(404).sendFile(path.join(__dirname, 'views', '404.html'));         // we dont need to put(../)--> because we already are in the root folder...                                // .status(404)-->method given by express 
  });
                                               
                                               
                                               
  app.listen(3000);                                              
 



//output: 
 
